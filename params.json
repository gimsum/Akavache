{"name":"Akavache","tagline":"An asynchronous, persistent key-value store","body":"## Akavache: An Asynchronous Key-Value Store for Native Applications\r\n\r\nAkavache is an *asynchronous*, *persistent* (i.e. writes to disk) key-value\r\nstore created for writing desktop and mobile applications in C#, based on\r\nSQLite3. Akavache is great for both storing important data (i.e. user\r\nsettings) as well as cached local data that expires.\r\n\r\n![Dat Logo](http://f.cl.ly/items/2R3d1o122m090K0W081L/Akavache.png)\r\n\r\n### Where can I use it?\r\n\r\nAkavache is currently compatible with:\r\n\r\n* Xamarin.iOS / Xamarin.Mac 32-bit\r\n* Xamarin.Android\r\n* .NET 4.5 Desktop (WPF)\r\n* Windows Phone 8\r\n* WinRT (Windows Store)\r\n* Windows Phone 8.1 Universal Apps\r\n\r\n### What does that mean?\r\n\r\nDownloading and storing remote data from the internet while still keeping the\r\nUI responsive is a task that nearly every modern application needs to do.\r\nHowever, many applications that don't take the consideration of caching into\r\nthe design from the start often end up with inconsistent, duplicated code for\r\ncaching different types of objects.\r\n\r\n[Akavache](https://github.com/github/akavache) is a library that makes common app\r\npatterns easy, and unifies caching of different object types (i.e. HTTP\r\nresponses vs. JSON objects vs. images).\r\n\r\nIt's built on a core key-value byte array store (conceptually similar to a\r\n`Dictionary<string, byte[]>`), and on top of that store, extensions are\r\nadded to support:\r\n\r\n- Arbitrary objects via JSON.NET\r\n- Fetching and loading Images and URLs from the Internet\r\n- Storing and automatically encrypting User Credentials\r\n\r\n## Platform-specific notes\r\n\r\n* **Xamarin.iOS / Xamarin.Mac 32-bit** - No issues.\r\n\r\n* **Xamarin.Android** - No issues.\r\n\r\n* **.NET 4.5 Desktop (WPF)** - No issues\r\n\r\n* **Windows Phone 8.0** - You must mark your application as `x86` or `ARM`, or\r\n  else you will get a strange runtime error about SQLitePCL_Raw not loading\r\n  correctly.\r\n\r\n* **WinRT (Windows Store)** - You must mark your application as `x86` or `ARM`, or\r\n  else you will get a strange runtime error about SQLitePCL_Raw not loading\r\n  correctly. You must *also* ensure that the Microsoft Visual C++ runtime is added\r\n  to your project. This means that you must submit several versions of your app\r\n  to the Store to support ARM.\r\n\r\n* **Windows Phone 8.1 Universal Apps** - You must mark your application as `x86`\r\n  or `ARM`, or else you will get a strange runtime error about SQLitePCL_Raw not\r\n  loading correctly. You must *also* ensure that the Microsoft Visual C++ runtime\r\n  is added to your project.\r\n\r\n### Getting Started\r\n\r\nInteracting with Akavache is primarily done through an object called\r\n`BlobCache`. At App startup, you must first set your app's name via\r\n`BlobCache.ApplicationName` - on the desktop, your application's data will be\r\nstored in `%AppData%\\[ApplicationName]` and\r\n`%LocalAppData%\\[ApplicationName]`. Store data that should be shared between\r\ndifferent machines in `BlobCache.UserAccount` and store data that is\r\nthrowaway or per-machine (such as images) in `BlobCache.LocalMachine`.\r\n\r\nThe most straightforward way to use Akavache is via the object extensions:\r\n\r\n```cs\r\nusing System.Reactive.Linq;   // IMPORTANT - this makes await work!\r\n\r\n// Make sure you set the application name before doing any inserts or gets\r\nBlobCache.ApplicationName = \"AkavacheExperiment\";\r\n\r\nvar myToaster = new Toaster();\r\nawait BlobCache.UserAccount.InsertObject(\"toaster\", myToaster);\r\n\r\n//\r\n// ...later, in another part of town...\r\n//\r\n\r\n// Using async/await\r\nvar toaster = await BlobCache.UserAccount.GetObject<Toaster>(\"toaster\");\r\n\r\n// or without async/await\r\nToaster toaster;\r\n\r\nBlobCache.UserAccount.GetObject<Toaster>(\"toaster\")\r\n    .Subscribe(x => toaster = x, ex => Console.WriteLine(\"No Key!\"));\r\n```\r\n\r\n### Handling Errors\r\n\r\nWhen a key is not present in the cache, GetObject throws a\r\nKeyNotFoundException (or more correctly, OnError's the IObservable). Often,\r\nyou would want to return a default value instead of failing:\r\n\r\n```cs\r\nToaster toaster;\r\n\r\ntry {\r\n    toaster = await BlobCache.UserAccount.GetObjectAsync(\"toaster\");\r\n} catch (KeyNotFoundException ex) {\r\n    toaster = new Toaster();\r\n}\r\n\r\n// Or without async/await:\r\ntoaster = await BlobCache.UserAccount.GetObjectAsync<Toaster>(\"toaster\")\r\n    .Catch(Observable.Return(new Toaster()));\r\n```\r\n\r\n### Examining Akavache caches\r\n\r\nUsing [Akavache Explorer](https://github.com/paulcbetts/AkavacheExplorer), you\r\ncan dig into Akavache repos for debugging purposes to see what has been stored.\r\n\r\n![](http://f.cl.ly/items/2D3Y0L0k262X0U0y3B0e/Image%202012.05.07%206:57:48%20PM.png)\r\n\r\n### What's this Global Variable nonsense? Why can't I use $FAVORITE_IOC_LIBRARY\r\n\r\nYou totally can. Just instantiate `SQLitePersistentBlobCache` or\r\n`SQLiteEncryptedBlobCache` instead - the static variables are there just to make it\r\neasier to get started.\r\n\r\n\r\n\r\n## Basic Method Documentation\r\n\r\nEvery blob cache supports the basic raw operations given below (some of them are\r\nnot implemented directly, but are added on via extension methods):\r\n\r\n```cs\r\n/*\r\n * Get items from the store\r\n */\r\n\r\n// Get a single item\r\nIObservable<byte[]> Get(string key);\r\n\r\n// Get a list of items\r\nIObservable<IDictionary<string, byte[]>> Get(IEnumerable<string> keys);\r\n\r\n// Get an object serialized via InsertObject\r\nIObservable<T> GetObject<T>(string key);\r\n\r\n// Get all objects of type T\r\nIObservable<IEnumerable<T>> GetAllObjects<T>();\r\n\r\n// Get a list of objects given a list of keys\r\nIObservable<IDictionary<string, T>> GetObjects<T>(IEnumerable<string> keys);\r\n\r\n/*\r\n * Save items to the store\r\n */\r\n\r\n// Insert a single item\r\nIObservable<Unit> Insert(string key, byte[] data, DateTimeOffset? absoluteExpiration = null);\r\n\r\n// Insert a set of items\r\nIObservable<Unit> Insert(IDictionary<string, byte[]> keyValuePairs, DateTimeOffset? absoluteExpiration = null);\r\n\r\n// Insert a single object\r\nIObservable<Unit> InsertObject<T>(string key, T value, DateTimeOffset? absoluteExpiration = null);\r\n\r\n// Insert a group of objects\r\nIObservable<Unit> InsertObjects<T>(IDictionary<string, T> keyValuePairs, DateTimeOffset? absoluteExpiration = null);\r\n\r\n/*\r\n * Remove items from the store\r\n */\r\n\r\n// Delete a single item\r\nIObservable<Unit> Invalidate(string key);\r\n\r\n// Delete a list of items\r\nIObservable<Unit> Invalidate(IEnumerable<string> keys);\r\n\r\n// Delete a single object (do *not* use Invalidate for items inserted with InsertObject!)\r\nIObservable<Unit> InvalidateObject<T>(string key);\r\n\r\n// Deletes a list of objects\r\nIObservable<Unit> InvalidateObjects<T>(IEnumerable<string> keys);\r\n\r\n// Deletes all items (regardless if they are objects or not)\r\nIObservable<Unit> InvalidateAll();\r\n\r\n// Deletes all objects of type T\r\nIObservable<Unit> InvalidateAllObjects<T>();\r\n\r\n/*\r\n * Get Metadata about items\r\n */\r\n\r\n// Return a list of all keys. Use for debugging purposes only.\r\nIObservable<IEnumerable<string>> GetAllKeys();\r\n\r\n// Return the time which an item was created\r\nIObservable<DateTimeOffset?> GetCreatedAt(string key);\r\n\r\n// Return the time which an object of type T was created\r\nIObservable<DateTimeOffset?> GetObjectCreatedAt<T>(string key);\r\n\r\n// Return the time which a list of keys were created\r\nIObservable<IDictionary<string, DateTimeOffset?>> GetCreatedAt(IEnumerable<string> keys);\r\n\r\n/*\r\n * Utility methods\r\n */\r\n\r\n// Attempt to ensure all outstanding operations are written to disk\r\nIObservable<Unit> Flush();\r\n\r\n// Preemptively drop all expired keys and run SQLite's VACUUM method on the\r\n// underlying database\r\nIObservable<Unit> Vacuum();\r\n```\r\n\r\n## Extension Method Documentation\r\n\r\nOn top of every `IBlobCache` object, there are extension methods that help with\r\ncommon application scenarios:\r\n\r\n```cs\r\n/*\r\n * Username / Login Methods (only available on ISecureBlobCache)\r\n */\r\n\r\n// Save login information for the given host\r\nIObservable<Unit> SaveLogin(string user, string password, string host = \"default\", DateTimeOffset? absoluteExpiration = null);\r\n\r\n// Load information for the given host\r\nIObservable<LoginInfo> GetLoginAsync(string host = \"default\");\r\n\r\n// Erase information for the given host\r\nIObservable<Unit> EraseLogin(string host = \"default\");\r\n\r\n/*\r\n * Downloading and caching URLs and Images\r\n */\r\n\r\n// Download a file as a byte array\r\nIObservable<byte[]> DownloadUrl(string url,\r\n    IDictionary<string, string> headers = null,\r\n    bool fetchAlways = false,\r\n    DateTimeOffset? absoluteExpiration = null);\r\n\r\n// Load a given key as an image\r\nIObservable<IBitmap> LoadImage(string key, float? desiredWidth = null, float? desiredHeight = null);\r\n\r\n// Download an image from the network and load it\r\nIObservable<IBitmap> LoadImageFromUrl(string url,\r\n    bool fetchAlways = false,\r\n    float? desiredWidth = null,\r\n    float? desiredHeight = null,\r\n    DateTimeOffset? absoluteExpiration = null);\r\n\r\n/*\r\n * Composite operations\r\n */\r\n\r\n// Attempt to return an object from the cache. If the item doesn't\r\n// exist or returns an error, call a Func to return the latest\r\n// version of an object and insert the result in the cache.\r\nIObservable<T> GetOrFetchObject<T>(string key, Func<Task<T>> fetchFunc, DateTimeOffset? absoluteExpiration = null);\r\n\r\n// Like GetOrFetchObject, but isn't async\r\nIObservable<T> GetOrCreateObject<T>(string key, Func<T> fetchFunc, DateTimeOffset? absoluteExpiration = null);\r\n\r\n// Immediately return a cached version of an object if available, but *always*\r\n// also execute fetchFunc to retrieve the latest version of an object.\r\nIObservable<T> GetAndFetchLatest<T>(string key,\r\n    Func<Task<T>> fetchFunc,\r\n    Func<DateTimeOffset, bool> fetchPredicate = null,\r\n    DateTimeOffset? absoluteExpiration = null);\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}